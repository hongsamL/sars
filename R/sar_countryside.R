
data=read.table("D:\\documents\\Work\\On-going projects\\Habitat SAR Models\\Countryside files\\Vania\\MatrixMHUb.txt", 1)

countryside_optim <- function(dat, mod_nam = NULL, startPar){
  

  #to be generic it needs to build based on number of habitats
  #provided by the user
  CNs <- colnames(dat)
  Nhab <- length(which(grepl("Area", CNs)))
  
  if (is.null(startPar)){
  
  start.vec <- c(0.005,0.05,0.5,1,5)
  start.list <- rep(list(start.vec), Nhab)
  start.list$z <- c(0.001, 0.01, 0.1, 0.5, 1)
  
  LNs <- sapply(1:Nhab, function(x) paste0("h", x))
  names(start.list) <- c(LNs, "z")
  
  grid.start <- expand.grid(start.list)
  
  #random for testing
  grid.start <-  grid.start[sample(1:nrow(grid.start), 150),]
  
  
  } else { #user provided start values
    
    if (length(startPar) != Nhab + 1){
      stop("Length of startPar must equal the number of",
           " habitats plus one")
    }
    
    grid.start <- as.data.frame(matrix(startPar, 
                                      nrow = 1))
    LNs <- sapply(1:Nhab, function(x) paste0("h", x))
    colnames(grid.start) <- c(LNs, "z")
  }
  
 y <- sapply(1:Nhab, function(x) paste0("h", x, "*", "Area", x))
 y <- toString(y)
 y <- gsub(", ", " + ", y)
 y <- paste0("S ~ (", y, ")", "^z")
 mod_nam2 <- formula(y)
  
  
#  mod_nam2 <- switch(mod_nam,
         #            "Country_power" = formula(y),
            #         "jigsaw" = formula(S ~ (c1 * H^d) * ((A / H)^z)))
  
  fit.list <- suppressWarnings(apply(grid.start, 1, function(x){
    tryCatch(minpack.lm::nlsLM(mod_nam2,
                               start = x,
                               control = minpack.lm::nls.lm.control(maxiter = 10000, 
                                                                    maxfev = 100000),
                               data = dat),
             error = function(e) NA)
  }))
  
  len.fit.list <- sapply(fit.list, length)
  if (any(len.fit.list > 1)){ #otherwise all NA
    good.fit.list <- which(len.fit.list > 1)
    new.fit.list <- fit.list[good.fit.list]
    AIC.fit.list <- vapply(new.fit.list, AIC, 
                           FUN.VALUE = numeric(1))
    #if multiple min, it just picks the first
    best.fit <- new.fit.list[[which.min(AIC.fit.list)]]
  } else {
    best.fit <- NA 
  }
  return(best.fit)
}


data=read.table("D:\\documents\\Work\\On-going projects\\Habitat SAR Models\\Countryside files\\Vania\\MatrixMHUb.txt", 1)
data <- data[,c(2:4, 6,8,7,9)]

f <- sar_countryside(data, ubiSp = TRUE)



sar_countryside <- function(data, modType = NULL,
                            startPar = NULL, ubiSp = FALSE){
  
  if (!(is.matrix(data) | is.data.frame(data)))
    stop('data must be a matrix or dataframe')
  if (is.matrix(data)) data <- as.data.frame(data)
  if (anyNA(data)) stop('NAs present in data')
  # if (!any(c("power", "logarithmic", "power_log") %in% 
  #          modType)){
  #   stop("modType should be one of 'power', 'logarithmic' or 'power_log'")
  # }
  if (!is.null(startPar)){
    ###needs to be a matrix, with each row corresponding to
    #habitat types in matching column order
  }
  if (!is.logical(ubiSp) | anyNA(ubiSp)){
      stop("ubiSp should be a logical vector of length 1 (column no.)")
  } else if (isTRUE(ubiSp)){
    if (ncol(data) %% 2 == 0){
      stop("If ubiSp == TRUE, there should be an odd number of columns")
    } 
  }
  
  ##Rename columns
  CN <- floor((ncol(data)) / 2)#if ubiSp, it will be 0.5 over (hence floor) 
  colnames(data)[1:3] <- sapply(1:CN, function(x) paste0("Area", x))
  colnames(data)[(CN + 1):(CN + CN)] <- sapply(1:CN, 
                                       function(x) paste0("SR", x))
  if (ubiSp) colnames(data)[ncol(data)] <- "SR_UB"

  ##Need to then fit the models for each SR, including for 
  #SR_UB if ubiSp.
  res <- lapply(((CN + 1):(CN + CN)), function(x){
    dum <- data[,c(1:CN, x)]
    dum <- dum[order(dum[,ncol(dum)]),]
    colnames(dum)[ncol(dum)] <- "S"
    countryside_optim(dat = dum, startPar = NULL)
  })
  names(res) <- colnames(data)[(CN + 1):(CN + CN)]
  
  if (ubiSp){
    dum <- data[,c(1:CN, ncol(data))]
    dum <- dum[order(dum[,ncol(dum)]),]
    colnames(dum)[ncol(dum)] <- "S"
    res$UB <- countryside_optim(dat = dum, startPar = NULL)
  }
  
  len <- sapply(fits, length)
  if (all(len == 1)){
    attr(res, "failedMods") <- "All"
  } else if (any(len == 1)){
    w1 <- which(len == 1)
    attr(res, "failedMods") <- w1
  } else {
    attr(res, "failedMods") <- "None"
  }

  class(res) <- c("habitat", "sars", "list")
  attr(res, "type") <- "countryside"
  return(res)
}


countryside_extrap <- function(fits, area, modType = NULL){
  
  #order of area values needs to match the order of 
  #the model fits in 'fits'
  
  if (!inherits(fits, "habitat")){
    stop("fits should be an object generated by sar_countryside")
  }
  
  if (attributes(fits)$type != "countryside"){
    stop("fits should be an object generated by sar_countryside")
  }
  
  #If any fits are NA, we need to remove these and also
  #the corresponding user-provided area value(s)
  len <- sapply(fits, length)
  if (all(len == 1)) stop("All model fits are NA")
  if (any(len == 1)){
    warning("Some elements in 'fits' are NA; ",
           "\nthese have been removed prior to extrapolation")
    w1 <- which(len == 1)
    fits[w1] <- NULL
    mes <- TRUE
  } else {
    mes <- FALSE
  }
  
  #number of habitat is no. of parameters - 1 (as one is z)
  Nhab <- length(fits[[1]]$m$getPars()) - 1
  if (length(area) != Nhab) {
    stop("Length of 'area' does not equal no. of habitats in 'fits'")
  }
  names(area) <- sapply(1:Nhab, function(x) paste0("Area", x))
  area <- as.list(area)
  
  #run predict() for each model in fits
  Pred <- vapply(fits, function(x){
    predict(x, area)
  }, FUN.VALUE = numeric(1))
  
  PredTot <- sum(Pred)
  
  resP <- list(Pred, PredTot, mes)
  return(resP)
}

countryside_extrap(f, 1:3)





#define CSAR 2 - used to estimate total species
CountrysideSAR2<-function(a1,a2,a3,par)
{
  species<-(a1*par[1]+par[2]*a2+par[3]*a3)^par[4]
  names(species)<-NULL
  species
}

# determine total species
TotalCSAR <- function (a1,a2,a3, f)
{
  sp.AG<-CountrysideSAR2(a1,a2,a3,coef(f[[1]]))
  sp.UB<-CountrysideSAR2(a1,a2,a3,coef(f[[4]]))	
  sp.SH<-CountrysideSAR2(a1,a2,a3,coef(f[[2]]))
  sp.QF<-CountrysideSAR2(a1,a2,a3,coef(f[[3]]))
  sp.AG+sp.SH+sp.QF+sp.UB
}

TotalCSAR(1,2,3,f)





